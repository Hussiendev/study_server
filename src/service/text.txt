give me the test cases for userController:
import logger from "../util/logger";
import { JSONMapper } from "../mapper/User.Mapper";
import { User } from "../models/Usermodel";
import { UserService } from "../service/userService";
import { BadRequestException } from "../util/exceptions/http/BadRequestException";
import { Request, Response } from "express";
import { hash } from "bcrypt";
import { InsufficientPermissionsException } from "../util/exceptions/http/AutharizationException";
import { ROLE } from "../config/roles";
import { AuthRequest } from "../config/authRequest";

export class UserController {
    constructor(private readonly userService: UserService) {}

    // -------------------------
    // CREATE USER
    // -------------------------
    public async createUser(req: Request, res: Response): Promise<void> {
        logger.info("Received request to create user");

        const userData: User = new JSONMapper().map(req.body);

        // Always hash password before saving
        userData.setPassword(await hash(userData.getPassword(), 10));

        const createdUser = await this.userService.createUser(userData);

        res.status(201).json({
            message: "User created successfully",
            user: new JSONMapper().reversemap(createdUser)
        });
    }

    // -------------------------
    // GET USER BY ID
    // -------------------------
    public async getUser(req: Request, res: Response): Promise<void> {
           const authReq = req as AuthRequest;
    const userId = req.params.id;

    this.enforceOwnership(authReq, userId);
        
        if (!userId) {
            throw new BadRequestException("User ID is required", { userId });
        }

        logger.info(`Fetching user with id: ${userId}`);

        const user = await this.userService.getUser(userId);

        res.status(200).json({
            message: "User retrieved successfully",
            user: new JSONMapper().reversemap(user)
        });
    }

    // -------------------------
    // GET ALL USERS
    // -------------------------
    public async getAllUsers(req: Request, res: Response): Promise<void> {
        logger.info("Fetching all users");
      

   
        const users = await this.userService.getAllUsers();
        const mappedUsers = users.map(user =>
            new JSONMapper().reversemap(user)
        );

        res.status(200).json({
            message: "Users retrieved successfully",
            count: mappedUsers.length,
            users: mappedUsers
        });
    }

    // -------------------------
    // UPDATE USER
    // -------------------------
    public async updateUser(req: Request, res: Response): Promise<void> {
        const authReq = req as AuthRequest;        
    
        const userId = req.params.id;
        this.enforceOwnership(authReq, userId);

        if (!userId) {
            throw new BadRequestException("User ID is required", { userId });
        }

        logger.info(`Updating user with id: ${userId}`);

        const userData: User = new JSONMapper().map(req.body);
        userData.setId(userId);

        // Hash password only if provided
        if (userData.getPassword()) {
            userData.setPassword(await hash(userData.getPassword(), 10));
        }

        await this.userService.updateUser(userData);

        res.status(200).json({
            message: "User updated successfully"
        });
    }

    // -------------------------
    // DELETE USER
    // -------------------------
    public async deleteUser(req: Request, res: Response): Promise<void> {
        const userId = req.params.id;
            const authReq = req as AuthRequest;
        this.enforceOwnership(authReq, userId);
        if (!userId) {
            throw new BadRequestException("User ID is required", { userId });
        }

        logger.info(`Deleting user with id: ${userId}`);

        await this.userService.deleteUser(userId);

        res.status(200).json({
            message: "User deleted successfully",
            userId
        });
    }
    private enforceOwnership(authReq: AuthRequest, targetUserId: string) {
    if (
        authReq.user!.role === ROLE.USER &&
        authReq.user!.userId !== targetUserId
    ) {
        throw new InsufficientPermissionsException();
    }
}

}

these ar related files:import { createUserRepo, UserRepo } from "../repository/User.repo";
import { User } from "../models/Usermodel";

import { BadRequestException } from "../util/exceptions/http/BadRequestException";

import logger from "../util/logger";
import bcrypt from "bcrypt";

export class UserService {

    private userRepo!: UserRepo;

    // -------------------------
    // CREATE USER
    // -------------------------
    public async createUser(user: User): Promise<User> {
        logger.info(`Creating user with email: ${user.getEmail()}`);

        this.validateNewUser(user);

        await (await this.getRepo()).create(user);

        return user;
    }

    // -------------------------
    // GET USER
    // -------------------------
    public async getUser(id: string): Promise<User> {
        logger.info(`Fetching user with id: ${id}`);
        return await (await this.getRepo()).get(id);
    }
    public async get_user_bymail(email:string):Promise<User>{
        return await(await this.getRepo()).getsUserbyEmail(email);
    }

   
    public async updateuserpass(email:string,pass:string){
        return await(await this.getRepo()).updatePassword(email,await bcrypt.hash(pass,10));


        
    }
  

    // -------------------------
    // GET ALL USERS
    // -------------------------
    public async getAllUsers(): Promise<User[]> {
        logger.info("Fetching all users");
        return await (await this.getRepo()).getALL();
    }

    // -------------------------
    // UPDATE USER
    // -------------------------
    public async updateUser(user: User): Promise<void> {
        logger.info(`Updating user with id: ${user.getId()}`);

        this.validateUpdateUser(user);

        await (await this.getRepo()).update(user);
    }

    // -------------------------
    // DELETE USER
    // -------------------------
    public async deleteUser(id: string): Promise<void> {
        logger.info(`Deleting user with id: ${id}`);
        await (await this.getRepo()).delete(id);
    }

    // -------------------------
    // LOGIN VALIDATION
    // -------------------------
    public async validate(email: string, password: string): Promise<User> {
        logger.info(`Validating user with email: ${email}`);

        const user = await (await this.getRepo()).getsUserbyEmail(email);

        const isMatch = await bcrypt.compare(password, user.getPassword());

        if (!isMatch) {
            throw new BadRequestException("Invalid password");
        }
        

        return user;
    }
    async updatedLoggedUser(email:string):Promise<void>{
        await (await this.getRepo()).Update_USER_VERF(email);

    }

    // -------------------------
    // VALIDATION FOR CREATE
    // -------------------------
    private validateNewUser(user: User): void {
        const email = user.getEmail();
        const name = user.getName();
        const password = user.getPassword();

        if (!name || !email || !password) {
            throw new BadRequestException(
                "Name, email, and password are required."
            );
        }

        this.validateEmail(email);

        if (password.length < 6) {
            throw new BadRequestException(
                "Password must be at least 6 characters long."
            );
        }
    }

    // -------------------------
    // VALIDATION FOR UPDATE
    // -------------------------
    private validateUpdateUser(user: User): void {
        if (!user.getId()) {
            throw new BadRequestException("User ID is required for update.");
        }

        if (user.getEmail()) {
            this.validateEmail(user.getEmail());
        }

        if (user.getPassword() && user.getPassword().length < 6) {
            throw new BadRequestException(
                "Password must be at least 6 characters long."
            );
        }
    }

    private validateEmail(email: string): void {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

        if (!emailRegex.test(email)) {
            throw new BadRequestException("Invalid email format.");
        }
    }

    private async getRepo(): Promise<UserRepo> {
        if (!this.userRepo) {
            this.userRepo = await createUserRepo();
        }
        return this.userRepo;
    }
}
import { User } from "../models/Usermodel";
import { id,  Intiazable, IRepository } from "./IRepo";
import { DBException, RepositoryInitializationException } from "../util/exceptions/RepoException";
import logger from "../util/logger";
import { ConnectionManager } from "./ConnectionManger";
import { NotFoundException } from "../util/exceptions/http/NotFoundException";

import { idGenerater } from "../util/IDgenerater";
import { SQLMapper, SQLUser } from "../mapper/User.Mapper";
import { ROLE } from "../config/roles";

export const createUser = `
CREATE TABLE IF NOT EXISTS "user" (
    id TEXT PRIMARY KEY,
    name VARCHAR(255) NOT NULL ,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user',
    last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_verified BOOLEAN DEFAULT FALSE,
   reset_token TEXT,
reset_token_expiration TIMESTAMP,
    refresh_token VARCHAR(255),
    refresh_token_expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
`;

export const insert_query = `
INSERT INTO "user" (id,name, email,password,role)
VALUES ($1, $2, $3,$4,$5);
`;
const addRoleColumn = `
ALTER TABLE "user" ADD COLUMN IF NOT EXISTS role TEXT DEFAULT '${ROLE.USER}';
`;
const Get_User='SELECT * FROM "user" WHERE id = $1;';
const Get_All_Users='SELECT * FROM "user";';
const Update_User='UPDATE "user" SET name = $1, email = $2, password = $3, role = $4, updated_at = CURRENT_TIMESTAMP WHERE id = $5;';
const Delete_User='DELETE FROM "user" WHERE id = $1;';
const Get_User_By_Email='SELECT * FROM "user" WHERE email = $1;';
const Update_Refresh_Token =
'UPDATE "user" SET refresh_token=$1,    refresh_token_expires_at=$2 WHERE id=$3;';
const Update_VeerfyEmail='UPDATE "user" SET is_verified =$1, last_login=CURRENT_TIMESTAMP WHERE email=$2;'
const Update_logout='UPDATE "user" SET is_verified =$1  WHERE id=$2;'

export class UserRepo implements IRepository<User>, Intiazable {

    async init(): Promise<void> {
        let connection;
        try {
            connection = await ConnectionManager.getConnection();
            await connection.query(createUser);
            await connection.query(addRoleColumn);
            logger.info("User table ensured in the database");
        } catch (error) {
            logger.error("Failed to initialize repository", error as Error);
            throw new RepositoryInitializationException(
                "Failed to initialize repository",
                error as Error
            );
        } finally {
            connection?.release();
        }
    }

    // -------------------------
    // CREATE
    // -------------------------
    async create(item: User): Promise<id> {
        let connection;
        const generatedId = idGenerater("user");

        try {
            connection = await ConnectionManager.getConnection();
            await connection.query("BEGIN");

            await connection.query(insert_query, [
                generatedId,
                item.getName(),
                item.getEmail(),
                item.getPassword(),
                item.getRole()
            ]);

            await connection.query("COMMIT");

            item.setId(generatedId);
            logger.info(`User created successfully: ${generatedId}`);
            return generatedId;

        } catch (error) {
            if (connection) await connection.query("ROLLBACK");

            logger.error("DB error during create", error as Error);
            throw new DBException("Error creating user", error as Error);

        } finally {
            connection?.release();
        }
    }

    // -------------------------
    // GET BY ID
    // -------------------------
    async get(id: id): Promise<User> {
        let connection;

        try {
            connection = await ConnectionManager.getConnection();
            const result = await connection.query<SQLUser>(Get_User, [id]);

            const row = result.rows[0];
            if (!row) {
                throw new NotFoundException(
                    `User with id ${id} not found`,
                    { userId: id }
                );
            }
           


            return new SQLMapper().map(row);

        } catch (error) {

            if (error instanceof NotFoundException) throw error;

            logger.error("DB error fetching user", error as Error);
            throw new DBException("Error fetching user", error as Error);

        } finally {
            connection?.release();
        }
    }

    // -------------------------
    // GET BY EMAIL
    // -------------------------
    async getsUserbyEmail(email: string): Promise<User> {
        let connection;

        try {
            connection = await ConnectionManager.getConnection();
            const result = await connection.query<SQLUser>(Get_User_By_Email, [email]);

            const row = result.rows[0];
            if (!row) {
                throw new NotFoundException(
                    `User with email ${email} not found`,
                    { email }
                );
            }
        

            return new SQLMapper().map(row);

        } catch (error) {

            if (error instanceof NotFoundException) throw error;

            logger.error("DB error fetching user by email", error as Error);
            throw new DBException("Error fetching user by email", error as Error);

        } finally {
            connection?.release();
        }
    }

    // -------------------------
    // GET ALL
    // -------------------------
    async getALL(): Promise<User[]> {
        let connection;

        try {
            connection = await ConnectionManager.getConnection();
            const result = await connection.query<SQLUser>(Get_All_Users);

            if (!result.rows.length) {
                return [];
            }

            const mapper = new SQLMapper();
            return result.rows.map(row => mapper.map(row));

        } catch (error) {
            logger.error("DB error fetching all users", error as Error);
            throw new DBException("Error fetching users", error as Error);

        } finally {
            connection?.release();
        }
    }

    // -------------------------
    // UPDATE
    // -------------------------
    async update(item: User): Promise<void> {
        let connection;

        try {
            connection = await ConnectionManager.getConnection();
            await connection.query("BEGIN");

            const result = await connection.query(Update_User, [
                item.getName(),
                item.getEmail(),
                item.getPassword(),
                item.getRole(),
                item.getId()
            ]);

            if (result.rowCount === 0) {
                throw new NotFoundException(
                    `User with id ${item.getId()} not found`,
                    { userId: item.getId() }
                );
            }

            await connection.query("COMMIT");
            logger.info(`User updated: ${item.getId()}`);

        } catch (error) {
            if (connection) await connection.query("ROLLBACK");

            if (error instanceof NotFoundException) throw error;

            logger.error("DB error during update", error as Error);
            throw new DBException("Error updating user", error as Error);

        } finally {
            connection?.release();
        }
    }

    // -------------------------
    // DELETE
    // -------------------------
    async delete(id: id): Promise<void> {
        let connection;

        try {
            connection = await ConnectionManager.getConnection();
            await connection.query("BEGIN");

            const result = await connection.query(Delete_User, [id]);

            if (result.rowCount === 0) {
                throw new NotFoundException(
                    `User with id ${id} not found`,
                    { userId: id }
                );
            }

            await connection.query("COMMIT");
            logger.info(`User deleted: ${id}`);

        } catch (error) {
            if (connection) await connection.query("ROLLBACK");

            if (error instanceof NotFoundException) throw error;

            logger.error("DB error during delete", error as Error);
            throw new DBException("Error deleting user", error as Error);

        } finally {
            connection?.release();
        }
    }
    async updateRefreshToken(userId: string, token: string | null,expired:Date|null): Promise<void> {
    const connection = await ConnectionManager.getConnection();
    try {
        await connection.query(Update_Refresh_Token, [token, expired,userId]);
    } finally {
        connection.release();
    }
}
async Update_USER_VERF(email:string):Promise<void>{
    const connection = await ConnectionManager.getConnection();
    try {
        await connection.query(Update_VeerfyEmail, [true, email]);
    } finally {
        connection.release();
    }

}
async Logout(userId:string):Promise<void>{
     const connection = await ConnectionManager.getConnection();
try {
        await connection.query(Update_logout, [false, userId]);
    } finally {
        connection.release();
    }

}
async updateResetToken(userId: string, token: string, expiration: Date) {
    const connection = await ConnectionManager.getConnection();
    try {
        await connection.query(
            `UPDATE "user" 
             SET reset_token=$1, reset_token_expiration=$2 
             WHERE id=$3`,
            [token, expiration, userId]
        );
    } finally {
        connection.release();
    }
}

async clearResetToken(email: string): Promise<void> {
    const connection = await ConnectionManager.getConnection();
    try {
        await connection.query(
            `UPDATE "user" 
             SET reset_token = NULL, reset_token_expiration = NULL 
             WHERE email = $1`,
            [email]
        );
    } finally {
        connection.release();
    }
}
// In User.repo.ts - ADD THIS METHOD
async getResetDataByEmail(email: string): Promise<{ 
    hashedToken: string; 
    expiresAt: Date 
} | null> {
    const connection = await ConnectionManager.getConnection();
    try {
        const result = await connection.query(
            `SELECT reset_token, reset_token_expiration 
             FROM "user" 
             WHERE email = $1`,
            [email]
        );
        
        if (result.rows.length === 0 || !result.rows[0].reset_token) {
            return null;
        }
        
        return {
            hashedToken: result.rows[0].reset_token,
            expiresAt: new Date(result.rows[0].reset_token_expiration)
        };
    } finally {
        connection.release();
    }
}

async updatePassword(email: string, newPassword: string) {
    const connection = await ConnectionManager.getConnection();
    try {
        await connection.query(
            `UPDATE "user" 
             SET password=$1, reset_token=NULL, reset_token_expiration=NULL 
             WHERE email=$2`,
            [newPassword, email]
        );
    } finally {
        connection.release();
    }
}

}


 export async function createUserRepo(): Promise<UserRepo> {
    const repo = new UserRepo();
    await repo.init();
    return repo;
    }