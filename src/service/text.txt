steps for authentication and authrization:
1>install dependecies:npm install jsonwebtoken
2>create the token payload
3>create sekret key and expirationdaate inside the config file
3>create Authentication SERVICE that will do the following:CreateToken,VerfyToken,LogoutToken(clear token)
4>use jwtsign for creatoin and jwtverfy for verfication
5>make new exception called Authentication ecxeption in http folder 
6>make authroutes
7>when jenrated the tokem and login is succesful when the frontend should give u the request it must be authenticated with the gnerated token and in order to read that token u must have a auth middlware
8>the token genrated will be inside the header after he bearer so you need when accesing it to put split
9>the auth middleware will do the following:
--->get the token from the header
-->verfy token
--->add payload
---->call next 
10>make a cookie generater ti store the token inside the cookir
11>cont logout function
12>download the cookie parser
13>make refresh token so till know u have 3 tokens:login token logout and refresh token
14>the refresh token is the same as generate token but it diifer with expiration here will put refresh token
15>Autharzation part
---->make role.ts file containing roles and permisions and adpat the rest of prject to it
---->change the validate to have a user and return a user and add role tp persist function
-->adjusgt the token payload so it have both iserid and role
........
Till know in my project i have made the following:
User repo that connects with the db
User service for crud operation
aUTH SERVICE for token genration ,the auth token is store in cookie and refresh token is stored in db
user controller
auth controler
for login till know the suer enter emiale and pass upon  it the follwing wil hapen:
   public async login(req:Request,res:Response){
    
            const {email,password} = req.body;
            if(!email || !password){
               throw new BadRequestException ("Email and password are required");
            }
            const user= await this.userService.validate(email,password);
          this.authService.persistAuthentication(res,{userId:user.id,role:toRole(user.role)} );
            await this.userService.updatedLoggedUser(user.email);
            res.json({message:'Login successful'});
        
      
      
        
    }
step 1: i will validate the email and pass using validation function inn user service:blic async validate(email: string, password: string): Promise<User> {
        logger.info(`Validating user with email: ${email}`);

        const user = await (await this.getRepo()).getsUserbyEmail(email);

        const isMatch = await bcrypt.compare(password, user.getPassword());

        if (!isMatch) {
            throw new BadRequestException("Invalid password");
        }
        

        return user;
    }
step 2:i will genrate the token that have userID and role for both auth and refresh and store them occasionly:async persistAuthentication(
        res: Response,
        payload: UserPayload,
       
    ) {
        const accessToken = this.generateAccessToken(payload);
        const refreshToken = this.generateRefreshToken(payload);

        const hashedRefresh = await bcrypt.hash(refreshToken, 10);

        this.setAccessCookie(res, accessToken);
        this.setRefreshCookie(res, refreshToken);
               const expired=new Date(
  Date.now() + ms(this.refreshExpiration)
)
        await (await this.getRepo()).updateRefreshToken(payload.userId, hashedRefresh,expired);

      
    }
    step 3:i will update user is verfied and tokens:  async updatedLoggedUser(email:string):Promise<void>{
        await (await this.getRepo()).Update_USER_VERF(email);

    }async Update_USER_VERF(email:string):Promise<void>{
    const connection = await ConnectionManager.getConnection();
    try {
        await connection.query(Update_VeerfyEmail, [true, email]);
    } finally {
        connection.release();
    }

}
and return succes ,but know i want to integrate emmail sending system at the same amnenr,service-->controller
i want to use brevo for smtp and api
all my secrete stuff is inside a cnfoge folder:import dotnev from "dotenv";
import path from "path";
import {StringValue} from "ms"
dotnev.config({path:path.join(__dirname,'../ ../.env')});
export default {
NODE_ENV: process.env.NODE_ENV || 'development',
is_Production: process.env.NODE_ENV === 'production',
logDir: 'logs', // Specifies the folder where log files will be saved.
port: process.env.PORT ? parseInt(process.env.PORT) : 4000, // Sets the port number for the application to listen on. It checks if a PORT environment variable is set; if not, it defaults to 3000.
host: process.env.HOST || 'localhost', // Sets the host address for the application. It checks if a HOST environment variable is set; if not, it defaults to 'localhost'.
Storage:{
      postgres:'postgresql://neondb_owner:npg_Q0eGUgSc9bYx@ep-still-violet-a4smcvre-pooler.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require'

},
auth:{
    jwtSecret: process.env.JWT_SECRET || 'secret_90909090',
     RefreshSecret: process.env.JWT_REFRESH_SECRET || 'secret_90909090', // Sets the secret key used for signing JSON Web Tokens (JWTs). It checks if a JWT_SECRET environment variable is set; if not, it defaults to
    expiration:(process.env.JWT_EXPIRATION || '15m') as StringValue,
      refreshExpiration:(process.env.JWT_REFRESH_EXPIRATION || '7d') as StringValue, // Sets the expiration time for JWTs. It checks if a JWT_EXPIRATION environment variable is set; if not, it defaults to '1h' (1 hour).
}
  
};i want to alter the login to do following and also add some routes:
user will still have same steps but the verf token is sent to his email
login-->verfy email-->use update user login function
note addd also permsions im using a role based method:// Define roles clearly
// roles.ts

export enum ROLE {
  ADMIN = 'admin',
  USER = 'user',
}

// Define all possible permissions
export enum PERMISSION {
  // User management
  CREATE_USER = 'user:create',
  READ_USER = 'user:read',
  UPDATE_USER = 'user:update',
  DELETE_USER = 'user:delete',
  READ_ALL_USERS = 'user:read:all',

  // Auth
  LOGIN = 'auth:login',
  LOGOUT = 'auth:logout',
}

// Map roles to their allowed permissions
type RolePermissions = {
  [key in ROLE]: PERMISSION[];
};

export const ROLE_PERMISSIONS: RolePermissions = {
  [ROLE.ADMIN]: [
    ...Object.values(PERMISSION), // Admin can do everything
  ],

  [ROLE.USER]: [
    PERMISSION.CREATE_USER,   // Can create his own account
    PERMISSION.READ_USER,     // Can read his own account
    PERMISSION.UPDATE_USER,   // Can update his own account
    PERMISSION.DELETE_USER,   // Can delete his own account
    PERMISSION.LOGIN,
    PERMISSION.LOGOUT,
  ],
};

export const toRole = (role: string): ROLE => {
    switch(role){
        case ROLE.ADMIN:
            return ROLE.ADMIN;
        case ROLE.USER:
            return ROLE.USER;
        default:
            throw new Error(`Invalid role: ${role}`);
    }
    }

give me step by step guide